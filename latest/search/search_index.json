{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Laravel Event-Sourcing","text":"<p>An event sourcing laravel package, complete with all the essential features, powered by the reliable Doctrine ecosystem and focused on developer experience. This package is a laravel integration for event-sourcing library.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Everything is included in the package for event sourcing</li> <li>Facades for easy access to event sourcing services and aggregates</li> <li>Developer experience oriented and fully typed</li> <li>Automatic snapshot-system to boost your performance</li> <li>Split big aggregates into multiple streams</li> <li>Versioned and managed lifecycle of subscriptions like projections and processors</li> <li>Safe usage of Personal Data with crypto-shredding</li> <li>Smooth upcasting of old events</li> <li>Simple setup with scheme management and doctrine migration</li> <li>Built in cli commands</li> <li>and much more...</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>composer require patchlevel/laravel-event-sourcing\n</code></pre> <p>Info</p> <p>More about installation can be found in the installation documentation.</p> <p>Tip</p> <p>Start with the quickstart to get a feeling for the package.</p>"},{"location":"facades/","title":"Facades","text":"<p>We offer facades for easy access to event sourcing services. You can use the facades to access the repositories, the store or manage your aggregates. This feature is optional, you can still use the services directly via dependency injection.</p>"},{"location":"facades/#aggregate","title":"Aggregate","text":"<p>If your aggregates extend the laravel package provided <code>AggregateRoot</code> class, you can use the helper methods to load and save your aggregates.</p> <p><pre><code>use Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\LaravelEventSourcing\\AggregateRoot;\n\n#[Aggregate(name: 'hotel')]\nfinal class Hotel extends AggregateRoot\n{\n    // ...\n}\n</code></pre> With the static <code>load</code> method of your specific aggregate class you can load your aggregates.</p> <p><pre><code>use Patchlevel\\EventSourcing\\Aggregate\\Uuid;\n\n$hotel = Hotel::load(Uuid::fromString('123'));\n</code></pre> And save them by using the <code>save</code> method on the aggregate instance.</p> <pre><code>$hotel-&gt;save();\n</code></pre>"},{"location":"facades/#repository","title":"Repository","text":"<p>You can access the specific repositories using the <code>get</code> method of the <code>Repository</code> facade.</p> <pre><code>use Patchlevel\\LaravelEventSourcing\\Facade\\Repository;\n\n$repository = Repository::get(Hotel::class);\n</code></pre>"},{"location":"facades/#store","title":"Store","text":"<p>You can access the store using the <code>Store</code> facade. There you can save multiple messages at once:</p> <p><pre><code>use Patchlevel\\LaravelEventSourcing\\Facade\\Store;\n\nStore::save(/* messages... */);\n</code></pre> or load messages by criteria:</p> <pre><code>use Patchlevel\\EventSourcing\\Store\\Criteria\\AggregateIdCriterion;\nuse Patchlevel\\EventSourcing\\Store\\Criteria\\Criteria;\nuse Patchlevel\\LaravelEventSourcing\\Facade\\Store;\n\n$messages = Store::load(\n    new Criteria(\n        new AggregateIdCriterion('123'),\n    ),\n)\n</code></pre> <p>Note</p> <p>This documentation is limited to the package integration. You should also read the library documentation.</p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>In our little getting started example, we manage hotels. We keep the example small, so we can only create hotels and let guests check in and check out.</p> <p>Info</p> <p>First of all, the package has to be installed and configured. If you haven't already done so, see the installation introduction.</p>"},{"location":"getting_started/#define-some-events","title":"Define some events","text":"<p>First we define the events that happen in our system.</p> <p>A hotel can be created with a <code>name</code> and an <code>id</code>:</p> <p><pre><code>namespace App\\Events;\n\nuse Patchlevel\\EventSourcing\\Aggregate\\Uuid;\nuse Patchlevel\\EventSourcing\\Attribute\\Event;\n\n#[Event('hotel.created')]\nfinal class HotelCreated\n{\n    public function __construct(\n        public readonly Uuid $id,\n        public readonly string $hotelName,\n    ) {\n    }\n}\n</code></pre> A guest can check in by <code>name</code>:</p> <p><pre><code>namespace App\\Events;\n\nuse Patchlevel\\EventSourcing\\Attribute\\Event;\n\n#[Event('hotel.guest_is_checked_in')]\nfinal class GuestIsCheckedIn\n{\n    public function __construct(\n        public readonly string $guestName,\n    ) {\n    }\n}\n</code></pre> And also check out again:</p> <pre><code>namespace App\\Events;\n\nuse Patchlevel\\EventSourcing\\Attribute\\Event;\n\n#[Event('hotel.guest_is_checked_out')]\nfinal class GuestIsCheckedOut\n{\n    public function __construct(\n        public readonly string $guestName,\n    ) {\n    }\n}\n</code></pre> <p>Note</p> <p>You can find out more about events in the library.</p>"},{"location":"getting_started/#define-aggregates","title":"Define aggregates","text":"<p>Next we need to define the hotel aggregate. How you can interact with it, which events happen and what the business rules are. For this we create the methods <code>create</code>, <code>checkIn</code> and <code>checkOut</code>. In these methods the business checks are made and the events are recorded. Last but not least, we need the associated apply methods to change the state.</p> <pre><code>namespace App\\Models;\n\nuse App\\Events\\GuestIsCheckedIn;\nuse App\\Events\\GuestIsCheckedOut;\nuse App\\Events\\HotelCreated;\nuse Patchlevel\\EventSourcing\\Aggregate\\Uuid;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Apply;\nuse Patchlevel\\EventSourcing\\Attribute\\Id;\nuse Patchlevel\\LaravelEventSourcing\\AggregateRoot;\n\nuse function array_filter;\nuse function array_values;\nuse function in_array;\nuse function sprintf;\n\n#[Aggregate(name: 'hotel')]\nfinal class Hotel extends AggregateRoot\n{\n    #[Id]\n    private Uuid $id;\n    private string $name;\n\n    /** @var list&lt;string&gt; */\n    private array $guests;\n\n    public function name(): string\n    {\n        return $this-&gt;name;\n    }\n\n    public function guests(): array\n    {\n        return $this-&gt;guests;\n    }\n\n    public static function create(Uuid $id, string $hotelName): self\n    {\n        $self = new self();\n        $self-&gt;recordThat(new HotelCreated($id, $hotelName));\n\n        return $self;\n    }\n\n    public function checkIn(string $guestName): void\n    {\n        if (in_array($guestName, $this-&gt;guests, true)) {\n            throw new RuntimeException(sprintf('Guest %s is already checked in', $guestName));\n        }\n\n        $this-&gt;recordThat(new GuestIsCheckedIn($guestName));\n    }\n\n    public function checkOut(string $guestName): void\n    {\n        if (!in_array($guestName, $this-&gt;guests, true)) {\n            throw new RuntimeException(sprintf('Guest %s is not checked in', $guestName));\n        }\n\n        $this-&gt;recordThat(new GuestIsCheckedOut($guestName));\n    }\n\n    #[Apply]\n    protected function applyHotelCreated(HotelCreated $event): void\n    {\n        $this-&gt;id = $event-&gt;id;\n        $this-&gt;name = $event-&gt;hotelName;\n        $this-&gt;guests = [];\n    }\n\n    #[Apply]\n    protected function applyGuestIsCheckedIn(GuestIsCheckedIn $event): void\n    {\n        $this-&gt;guests[] = $event-&gt;guestName;\n    }\n\n    #[Apply]\n    protected function applyGuestIsCheckedOut(GuestIsCheckedOut $event): void\n    {\n        $this-&gt;guests = array_values(\n            array_filter(\n                $this-&gt;guests,\n                static fn ($name) =&gt; $name !== $event-&gt;guestName,\n            ),\n        );\n    }\n}\n</code></pre> <p>Note</p> <p>You can find out more about aggregates in the library.</p>"},{"location":"getting_started/#define-projections","title":"Define projections","text":"<p>So that we can see all the hotels on our website and also see how many guests are currently visiting the hotels, we need a projection for it. To create a projection we need a projector. Each projector is then responsible for a specific projection.</p> <p><pre><code>namespace App\\Subscribers;\n\nuse App\\Events\\GuestIsCheckedIn;\nuse App\\Events\\GuestIsCheckedOut;\nuse App\\Events\\HotelCreated;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Schema;\nuse Patchlevel\\EventSourcing\\Aggregate\\Uuid;\nuse Patchlevel\\EventSourcing\\Attribute\\Projector;\nuse Patchlevel\\EventSourcing\\Attribute\\Setup;\nuse Patchlevel\\EventSourcing\\Attribute\\Subscribe;\nuse Patchlevel\\EventSourcing\\Attribute\\Teardown;\nuse Patchlevel\\EventSourcing\\Subscription\\Subscriber\\SubscriberUtil;\n\n#[Projector('hotel')]\nfinal class HotelProjection\n{\n    use SubscriberUtil;\n\n    /** @return list&lt;array{id: string, name: string, guests: int}&gt; */\n    public function getHotels(): array\n    {\n        return DB::select('select id, name, guests from ' . $this-&gt;table());\n    }\n\n    #[Subscribe(HotelCreated::class)]\n    public function handleHotelCreated(HotelCreated $event): void\n    {\n        DB::insert(\n            \"insert into {$this-&gt;table()} (id, name, guests) values (?, ?, ?)\",\n            [\n                $event-&gt;id-&gt;toString(),\n                $event-&gt;hotelName,\n                0,\n            ],\n        );\n    }\n\n    #[Subscribe(GuestIsCheckedIn::class)]\n    public function handleGuestIsCheckedIn(Uuid $hotelId): void\n    {\n        DB::update(\n            \"update {$this-&gt;table()} set guests = guests + 1 where id = ?\",\n            [$hotelId-&gt;toString()],\n        );\n    }\n\n    #[Subscribe(GuestIsCheckedOut::class)]\n    public function handleGuestIsCheckedOut(Uuid $hotelId): void\n    {\n        DB::update(\n            \"update {$this-&gt;table()} set guests = guests - 1 where id = ?\",\n            [$hotelId-&gt;toString()],\n        );\n    }\n\n    #[Setup]\n    public function create(): void\n    {\n        Schema::create($this-&gt;table(), static function (Blueprint $table): void {\n            $table-&gt;uuid('id')-&gt;primary();\n            $table-&gt;string('name');\n            $table-&gt;integer('guests');\n        });\n    }\n\n    #[Teardown]\n    public function drop(): void\n    {\n        Schema::dropIfExists('hotels');\n    }\n\n    private function table(): string\n    {\n        return 'projection_' . $this-&gt;subscriberId();\n    }\n}\n</code></pre> You need to register the projector in the <code>event-sourcing.php</code> configuration file.</p> <pre><code>use App\\Subscribers\\HotelProjection;\n\nreturn [\n    'subscribers' =&gt; [\n        HotelProjection::class,\n    ],\n];\n</code></pre> <p>Note</p> <p>You can find out more about projections in the library.</p>"},{"location":"getting_started/#processor","title":"Processor","text":"<p>In our example we also want to send an email to the head office as soon as a guest is checked in.</p> <p><pre><code>namespace App\\Subscribers;\n\nuse App\\Events\\GuestIsCheckedIn;\nuse Illuminate\\Mail\\Message;\nuse Illuminate\\Support\\Facades\\Mail;\nuse Patchlevel\\EventSourcing\\Attribute\\Processor;\nuse Patchlevel\\EventSourcing\\Attribute\\Subscribe;\n\nuse function sprintf;\n\n#[Processor('admin_emails')]\nfinal class SendCheckInEmailProcessor\n{\n    #[Subscribe(GuestIsCheckedIn::class)]\n    public function onGuestIsCheckedIn(GuestIsCheckedIn $event): void\n    {\n        Mail::raw('Event Sourcing is amazing!', static function (Message $message) use ($event): void {\n            $message\n                -&gt;subject(sprintf('Guest %s checked in', $event-&gt;guestName))\n                -&gt;to('info@patchlevel.de');\n        });\n    }\n}\n</code></pre> You need to register the processor in the <code>event-sourcing.php</code> configuration file.</p> <pre><code>use App\\Subscribers\\SendCheckInEmailProcessor;\n\nreturn [\n    'subscribers' =&gt; [\n        SendCheckInEmailProcessor::class,\n    ],\n];\n</code></pre> <p>Note</p> <p>You can find out more about processor in the library</p>"},{"location":"getting_started/#usage","title":"Usage","text":"<p>We are now ready to use the Event Sourcing System. To demonstrate this, we create a controller that allows us to create hotels and check in and out guests.</p> <p><pre><code>namespace App\\Http\\Controllers;\n\nuse App\\Models\\Hotel;\nuse App\\Subscribers\\HotelProjection;\nuse Illuminate\\Http\\JsonResponse;\nuse Illuminate\\Http\\Request;\nuse Patchlevel\\EventSourcing\\Aggregate\\Uuid;\n\nuse function response;\n\nfinal class HotelController\n{\n    public function __construct(\n        private readonly HotelProjection $hotelProjection,\n    ) {\n    }\n\n    public function list(): JsonResponse\n    {\n        return response()-&gt;json(\n            $this-&gt;hotelProjection-&gt;getHotels(),\n        );\n    }\n\n    public function create(Request $request): JsonResponse\n    {\n        $hotelName = $request-&gt;json('name'); // need validation!\n\n        $id = Uuid::generate();\n\n        $hotel = Hotel::create($id, $hotelName);\n        $hotel-&gt;save();\n\n        return response()-&gt;json(['id' =&gt; $id-&gt;toString()]);\n    }\n\n    public function checkIn(string $id, Request $request): JsonResponse\n    {\n        $guestName = $request-&gt;request-&gt;get('name'); // need validation!\n\n        $hotel = Hotel::load(Uuid::fromString($id));\n        $hotel-&gt;checkIn($guestName);\n        $hotel-&gt;save();\n\n        return response()-&gt;json();\n    }\n\n    public function checkOut(string $id, Request $request): JsonResponse\n    {\n        $guestName = $request-&gt;request-&gt;get('name'); // need validation!\n\n        $hotel = Hotel::load(Uuid::fromString($id));\n        $hotel-&gt;checkOut($guestName);\n        $hotel-&gt;save();\n\n        return response()-&gt;json();\n    }\n}\n</code></pre> The last step is to define the routes in the <code>routes/api.php</code> file.</p> <pre><code>use App\\Http\\Controllers\\HotelController;\nuse Illuminate\\Support\\Facades\\Route;\n\nRoute::get('/hotel', [HotelController::class, 'list']);\nRoute::post('/hotel/create', [HotelController::class, 'create']);\nRoute::post('/hotel/{id}/check-in', [HotelController::class, 'checkIn']);\nRoute::post('/hotel/{id}/check-out', [HotelController::class, 'checkOut']);\n</code></pre> <p>Warning</p> <p>Don't forget to define the path to the api routes in the <code>bootstrap/app.php</code> configuration file.</p>"},{"location":"getting_started/#result","title":"Result","text":"<p>Success</p> <p>We have successfully implemented and used event sourcing.</p> <p>Feel free to browse further in the documentation for more detailed information.  If there are still open questions, create a ticket on Github and we will try to help you.</p> <p>Note</p> <p>This documentation is limited to the package integration. You should also read the library documentation.</p>"},{"location":"installation/","title":"Installation","text":"<p>This guide will help you to install the package in your laravel project.</p>"},{"location":"installation/#require-package","title":"Require package","text":"<p>The first thing to do is to install packet if it has not already been done.</p> <pre><code>composer require patchlevel/laravel-event-sourcing=1.0.0-beta2\n</code></pre> <p>Note</p> <p>how to install composer</p>"},{"location":"installation/#configuration","title":"Configuration","text":"<p>Next you need to publish the event sourcing config file. It will be published to <code>config/event-sourcing.php</code></p> <pre><code>php artisan vendor:publish --tag patchlevel-config\n</code></pre>"},{"location":"installation/#migrations","title":"Migrations","text":"<p>You can publish the migrations with the following command:</p> <p><pre><code>php artisan vendor:publish --tag patchlevel-migrations\n</code></pre> And then run the migrations:</p> <pre><code>php artisan migrate\n</code></pre>"},{"location":"installation/#middlewares","title":"Middlewares","text":"<p>Some features need a middleware to work properly. You should add the middleware to your <code>bootstrap/app.php</code> file.</p> <pre><code>use Patchlevel\\LaravelEventSourcing\\Middleware\\EventSourcingMiddleware;\n\n-&gt;withMiddleware(static function (Middleware $middleware): void {\n    $middleware-&gt;append(EventSourcingMiddleware::class);\n})\n</code></pre> <p>Success</p> <p>You have successfully installed the package!  You can now start using the event sourcing library in your laravel project. Start with the quickstart to get a feeling for the package.</p> <p>Note</p> <p>This documentation is limited to the package integration. You should also read the library documentation.</p>"}]}